<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>notcord â€” multi-channel</title>
  <style>
    :root{
      --theme-1: #071226;
      --theme-2: #07101a;
      --muted: #9aa4b2;
      --accent: #5865f2;
      --msg-bg: #111827;
      --me-bg: #2b3440;
      --border: rgba(255,255,255,0.06);
      --text: #e6eef6;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Helvetica,Arial;color:var(--text);
      background:linear-gradient(180deg,var(--theme-1) 0%, var(--theme-2) 100%);
    }
    .app { width:100%; height:100vh; display:grid; grid-template-columns:260px 1fr 240px; overflow:hidden; }
    .sidebar{ padding:14px; display:flex; flex-direction:column; gap:12px; height:100vh; overflow:auto; background:linear-gradient(180deg,var(--theme-1),var(--theme-2)); border-right:1px solid var(--border) }
    .brand{display:flex;gap:10px;align-items:center;font-weight:700;color:var(--accent);font-size:18px}
    .brand .dot{width:18px;height:18px;border-radius:50%;background:linear-gradient(135deg,var(--theme-1),var(--theme-2));box-shadow:0 0 8px rgba(0,0,0,0.6)}
    .brand .name{background:linear-gradient(90deg,var(--theme-1),var(--theme-2));-webkit-background-clip:text;background-clip:text;color:transparent;font-weight:800}
    .usernameBox{display:flex;gap:8px;align-items:center}
    .usernameBox input{flex:1;padding:8px;background:transparent;border:1px solid var(--border);border-radius:8px;color:inherit;outline:none}
    .usernameBox button{padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--muted);cursor:pointer}
    .usernameLocked{display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid var(--border);font-weight:600;overflow:hidden}
    .channels{margin-top:6px;display:flex;flex-direction:column;gap:6px}
    .channel{padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer;border:1px solid transparent;display:flex;justify-content:space-between;align-items:center}
    .channel:hover{background:rgba(255,255,255,0.01)}
    .channel.active{background:linear-gradient(90deg, rgba(88,101,242,0.12), rgba(88,101,242,0.02));color:var(--text);border-color:rgba(88,101,242,0.12)}
    .settings{margin-top:auto;display:flex;flex-direction:column;gap:8px;padding-top:8px;border-top:1px solid var(--border)}
    .settings label{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px}
    .settings input[type="color"]{width:48px;height:32px;padding:0;border:none;background:transparent;cursor:pointer}
    .settings .toggleBtn{padding:8px;border-radius:8px;background:transparent;border:1px solid var(--border);color:var(--muted);cursor:pointer}

    .chatPanel{display:flex;flex-direction:column;min-height:0}
    .header{padding:12px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px}
    .header h2{margin:0;font-size:18px}
    .header .spacer{flex:1}
    .header .right{display:flex;flex-direction:column;align-items:flex-end;gap:2px}
    .status{color:var(--muted);font-size:13px}
    .typing{color:var(--muted);font-size:12px;height:18px}

    .messages{flex:1;overflow:auto;padding:20px;display:flex;flex-direction:column;gap:12px;scroll-behavior:smooth;min-height:0}
    .message{display:flex;gap:12px;align-items:flex-start;max-width:85%}
    .message.me{margin-left:auto;justify-content:flex-end}
    .bubble{background:var(--msg-bg);padding:10px 12px;border-radius:12px;display:flex;flex-direction:column;gap:6px;color:#dbe8ff;word-break:break-word;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    .message.me .bubble{background:var(--me-bg)}
    .meta{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
    .meta .name{font-weight:700}
    .meta .time{font-size:12px;color:var(--muted)}
    .text{white-space:pre-wrap;color:inherit;font-size:15px;word-break:break-word;overflow-wrap:break-word}
    .privateTag{font-size:12px;color:#ffd980;margin-left:8px}

    .inputArea{padding:12px;border-top:1px solid var(--border);display:flex;gap:8px;align-items:flex-end;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
    .inputArea textarea{flex:1;min-height:44px;max-height:160px;resize:none;padding:10px;border-radius:10px;background:transparent;border:1px solid var(--border);color:inherit;outline:none}
    .controls{display:flex;flex-direction:column;align-items:flex-end;gap:6px;min-width:120px}
    .charCount{font-size:12px;color:var(--muted)}
    .sendBtn{background:var(--accent);border:none;color:white;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600}
    .sendBtn:disabled{opacity:0.6;cursor:default}

    .playersPanel{background:linear-gradient(180deg,var(--theme-1),var(--theme-2));border-left:1px solid var(--border);padding:14px;display:flex;flex-direction:column;gap:12px;height:100vh;overflow:auto}
    .playersPanel h3{margin:0;font-size:15px;color:var(--muted)}
    .playersList{display:flex;flex-direction:column;gap:6px;overflow:auto}
    .player{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid transparent;color:var(--text)}
    .player.offline{opacity:0.6}
    .player .statusDot{width:10px;height:10px;border-radius:50%;margin-right:8px;flex-shrink:0}
    .player.online .statusDot{background:#39d353;box-shadow:0 0 8px rgba(57,211,83,0.12)}
    .player.offline .statusDot{background:#a0a0a0}

    @media (max-width:980px){ .app{grid-template-columns:220px 1fr 160px} }
    @media (max-width:720px){ .app{grid-template-columns:1fr} .sidebar,.playersPanel{display:none} }
  </style>
</head>
<body>
  <div class="app" id="app">
    <aside class="sidebar" id="sidebar">
      <div class="brand"><div class="dot"></div><div class="name">notcord</div></div>

      <div id="usernameSection">
        <div class="usernameBox" id="usernameBox">
          <input type="text" id="usernameInput" placeholder="Choose username (once)" maxlength="40" />
          <button id="setNameBtn">Set</button>
        </div>
        <div class="usernameLocked" id="usernameLocked" style="display:none">
          <div id="usernameDisplay"></div>
        </div>
      </div>

      <div class="channels" id="channels">
        <div class="channel active" data-id="general" role="button"># general</div>
        <div class="channel" data-id="school" role="button"># school</div>
        <div class="channel" data-id="games" role="button"># games</div>
        <div class="channel" data-id="announcements" role="button"># announcements <span class="lock">ðŸ”’</span></div>
      </div>

      <div class="settings" aria-label="Appearance settings">
        <label>Your name color
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="nameColor" title="Name color" />
            <div style="flex:1"></div>
            <button id="resetNameColor" class="toggleBtn">Reset</button>
          </div>
        </label>

        <label>Theme color 1
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="themeColor1" title="Theme color 1" />
            <div style="flex:1"></div>
            <button id="resetTheme1" class="toggleBtn">Reset</button>
          </div>
        </label>

        <label>Theme color 2
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="themeColor2" title="Theme color 2" />
            <div style="flex:1"></div>
            <button id="resetTheme2" class="toggleBtn">Reset</button>
          </div>
        </label>

        <div style="font-size:12px;color:var(--muted);padding-top:6px">Username and appearance are saved in this browser.<br/>Use "/w name text" to send a private message.</div>
      </div>
    </aside>

    <section class="chatPanel">
      <div class="header">
        <h2 id="channelTitle"># general</h2>
        <div class="spacer"></div>
        <div class="right">
          <div id="status" class="status">Connecting...</div>
          <div id="typingIndicator" class="typing"></div>
        </div>
      </div>

      <div class="messages" id="messages" role="log" aria-atomic="false"></div>

      <div class="inputArea" id="inputArea">
        <textarea id="messageInput" placeholder="Message (Shift+Enter for newline)" maxlength="100"></textarea>
        <div class="controls">
          <div class="charCount" id="charCount">0 / 100</div>
          <button id="sendBtn" class="sendBtn" disabled>Send</button>
        </div>
      </div>
    </section>

    <aside class="playersPanel" id="playersPanel">
      <h3>Players</h3>
      <div id="playersStatus" style="font-size:13px;color:var(--muted)">Loading...</div>
      <div style="height:6px"></div>
      <div class="playersList" id="playersList" aria-live="polite"></div>
    </aside>
  </div>

  <script>
    (function(){
      // APIs
      const CHANNELS = {
        general: 'https://68e839b2f2707e6128ca35e1.mockapi.io/chat',
        school:  'https://68eeed86b06cc802829ba196.mockapi.io/schoolchat',
        games:   'https://68eeed86b06cc802829ba196.mockapi.io/gameschat'
      };
      const PLAYERS_API = 'https://68e839b2f2707e6128ca35e1.mockapi.io/players';

      // Read-only announcements (editable in code)
      const READ_ONLY_MESSAGES = [
        { username: 'Admin', message: 'Welcome to notcord â€” check pinned notes here.', createdAt: new Date().toISOString(), nameColor: '#ff7a18' },
        { username: 'Team',  message: 'Server maintenance scheduled: Sunday 02:00 UTC.', createdAt: new Date(Date.now() - 1000 * 60 * 60 * 6).toISOString(), nameColor: '#18a0ff' }
      ];

      // DOM refs
      const channelsEl = document.getElementById('channels');
      const channelTitleEl = document.getElementById('channelTitle');
      const messagesEl = document.getElementById('messages');
      const statusEl = document.getElementById('status');
      const typingIndicatorEl = document.getElementById('typingIndicator');
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');
      const charCountEl = document.getElementById('charCount');

      const usernameBox = document.getElementById('usernameBox');
      const usernameInput = document.getElementById('usernameInput');
      const setNameBtn = document.getElementById('setNameBtn');
      const usernameLocked = document.getElementById('usernameLocked');
      const usernameDisplay = document.getElementById('usernameDisplay');

      const nameColorInput = document.getElementById('nameColor');
      const themeColor1Input = document.getElementById('themeColor1');
      const themeColor2Input = document.getElementById('themeColor2');
      const resetNameColorBtn = document.getElementById('resetNameColor');
      const resetTheme1Btn = document.getElementById('resetTheme1');
      const resetTheme2Btn = document.getElementById('resetTheme2');

      const playersListEl = document.getElementById('playersList');
      const playersStatusEl = document.getElementById('playersStatus');

      // state
      let activeChannel = localStorage.getItem('notcord_channel') || 'general';
      let apiBase = CHANNELS[activeChannel] || null;
      let polling = null;
      let playersPolling = null;
      let isSending = false;
      const MAX_CHARS = 100;

      // typing (localStorage-based)
      const TYPING_KEY = 'notcord_typing_v1';
      const TYPING_EXPIRE_MS = 5000;
      let isLocalTyping = false;
      let typingStopTimeout = null;

      // auto-scroll state
      let autoScroll = true;
      const AUTO_SCROLL_THRESHOLD = 60; // px from bottom considered "at bottom"

      // user settings & player id
      let username = localStorage.getItem('notcord_username') || '';
      let nameColor = localStorage.getItem('notcord_nameColor') || '#ffcc00';
      let themeColor1 = localStorage.getItem('notcord_theme1') || '#071226';
      let themeColor2 = localStorage.getItem('notcord_theme2') || '#07101a';
      let accentColor = localStorage.getItem('notcord_accent') || themeColor1;
      let localPlayerId = localStorage.getItem('notcord_playerId') || null;

      // theme
      function applyTheme(){
        document.documentElement.style.setProperty('--theme-1', themeColor1);
        document.documentElement.style.setProperty('--theme-2', themeColor2);
        document.documentElement.style.setProperty('--accent', accentColor || themeColor1);
      }
      function initializeAppearanceInputs(){
        nameColorInput.value = nameColor;
        themeColor1Input.value = themeColor1;
        themeColor2Input.value = themeColor2;
      }

      function setStatus(txt){ statusEl.textContent = txt; }

      // helpers
      function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
      function formatTime(iso){
        try{ const d = new Date(iso); if(isNaN(d)) return ''; return d.toLocaleString([], { hour: '2-digit', minute: '2-digit' }); }catch(e){return ''}
      }

      // message rendering & private logic
      function detectNameColorFromMsg(msg){ return msg.nameColor || msg.color || msg.name_color || null; }

      function renderMessage(msg, localUsername){
        // Private visibility: render only if not private OR private to local user OR authored by local user
        if(msg.privateTo && !(msg.privateTo === localUsername || (msg.username === localUsername))) return null;

        const container = document.createElement('div');
        const author = msg.username || msg.name || 'Unknown';
        const isMe = author === localUsername;
        container.className = 'message' + (isMe ? ' me' : '');

        const bubble = document.createElement('div'); bubble.className = 'bubble';
        const meta = document.createElement('div'); meta.className = 'meta';
        const nameEl = document.createElement('span'); nameEl.className = 'name';
        nameEl.textContent = author;

        const msgColor = detectNameColorFromMsg(msg);
        if(msgColor) nameEl.style.color = msgColor;
        else if(isMe && nameColor) nameEl.style.color = nameColor;

        const timeEl = document.createElement('span'); timeEl.className = 'time';
        timeEl.textContent = formatTime(msg.createdAt || msg.created_at || msg.timestamp || msg.time || '');

        meta.appendChild(nameEl);
        meta.appendChild(timeEl);

        if(msg.privateTo) {
          const tag = document.createElement('span');
          tag.className = 'privateTag';
          tag.textContent = msg.username === localUsername ? `to ${msg.privateTo}` : `private`;
          meta.appendChild(tag);
        }

        const text = document.createElement('div'); text.className = 'text';
        text.textContent = msg.message || msg.text || msg.content || '';

        bubble.appendChild(meta);
        bubble.appendChild(text);
        container.appendChild(bubble);
        return container;
      }

      function isAtBottom(){
        return messagesEl.scrollTop + messagesEl.clientHeight >= messagesEl.scrollHeight - AUTO_SCROLL_THRESHOLD;
      }

      function scrollToBottom(){
        requestAnimationFrame(()=> messagesEl.scrollTop = messagesEl.scrollHeight);
      }

      // Fetch messages (filter private messages not for current user) with scroll preservation
      async function fetchMessagesFromApi(){
        if(!apiBase) return false;
        try{
          const res = await fetch(apiBase);
          if(!res.ok) throw new Error('Fetch failed: '+res.status);
          const data = await res.json();
          if(!Array.isArray(data)) return false;
          data.sort((a,b)=>{
            const ta = new Date(a.createdAt||a.created_at||a.timestamp||0).getTime() || (Number(a.id)||0);
            const tb = new Date(b.createdAt||b.created_at||b.timestamp||0).getTime() || (Number(b.id)||0);
            return ta - tb;
          });

          // preserve scroll position if user scrolled up (not autoScroll)
          const prevScrollTop = messagesEl.scrollTop;
          const prevScrollHeight = messagesEl.scrollHeight;
          const wasAtBottom = isAtBottom();

          messagesEl.innerHTML = '';
          for(const msg of data){
            const el = renderMessage(msg, username);
            if(el) messagesEl.appendChild(el);
          }

          // If user is at bottom or autoScroll is enabled, scroll to bottom; otherwise maintain relative position
          if(wasAtBottom || autoScroll){
            scrollToBottom();
          } else {
            // preserve view (approx): keep the same distance from top accounting for new height
            const newScrollHeight = messagesEl.scrollHeight;
            messagesEl.scrollTop = Math.max(0, newScrollHeight - prevScrollHeight + prevScrollTop);
          }

          setStatus('Connected â€” ' + data.length + ' messages');
          return true;
        }catch(err){
          console.error(err);
          setStatus('Error fetching messages');
          return false;
        }
      }

      async function loadReadOnlyMessages(){
        const data = Array.isArray(READ_ONLY_MESSAGES) ? READ_ONLY_MESSAGES.slice() : [];
        data.sort((a,b)=> (new Date(a.createdAt||0).getTime()) - (new Date(b.createdAt||0).getTime()));
        const prevScrollTop = messagesEl.scrollTop;
        const prevScrollHeight = messagesEl.scrollHeight;
        const wasAtBottom = isAtBottom();

        messagesEl.innerHTML = '';
        for(const msg of data){
          const el = renderMessage(msg, username);
          if(el) messagesEl.appendChild(el);
        }

        if(wasAtBottom || autoScroll) scrollToBottom();
        else messagesEl.scrollTop = Math.max(0, messagesEl.scrollHeight - prevScrollHeight + prevScrollTop);

        setStatus('Announcements â€” ' + data.length + ' items (read-only)');
        return true;
      }

      async function fetchMessages(){ if(activeChannel === 'announcements') return loadReadOnlyMessages(); return fetchMessagesFromApi(); }

      // post: supports whisper: /w name text
      async function postMessage(rawText){
        if(!rawText || !rawText.trim()) return;
        if(!username){ setStatus('Set username first'); return; }
        if(!apiBase){ setStatus('No channel selected'); return; }
        if(isSending) return;
        isSending = true;
        sendBtn.disabled = true;

        // parse whisper syntax
        let privateTo = null;
        let messageText = rawText.trim();
        if(messageText.toLowerCase().startsWith('/w ')){
          const match = messageText.match(/^\/w\s+(\S+)\s+([\s\S]+)$/i);
          if(match){
            privateTo = match[1];
            messageText = match[2];
            if(!messageText){ setStatus('Whisper requires text'); isSending=false; sendBtn.disabled=false; return; }
          } else {
            setStatus('Whisper format: /w name text');
            isSending=false; sendBtn.disabled=false; return;
          }
        }

        const payload = {
          username,
          message: messageText,
          createdAt: new Date().toISOString(),
          nameColor,
          privateTo: privateTo || null,
          isPrivate: !!privateTo
        };

        // optimistic render (show to sender)
        const optimisticEl = renderMessage(payload, username);
        if(optimisticEl) messagesEl.appendChild(optimisticEl);
        if(autoScroll) scrollToBottom();

        try{
          const res = await fetch(apiBase, {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify(payload)
          });
          if(!res.ok) throw new Error('Send failed: ' + res.status);
          await fetchMessages();
        }catch(err){
          console.error(err);
          setStatus('Failed to send message');
          const timeEl = optimisticEl && optimisticEl.querySelector('.meta .time');
          if(timeEl) timeEl.textContent += ' (failed)';
        }finally{
          isSending = false;
          sendBtn.disabled = false;
        }
      }

      // === Players handling: fetch all players from PLAYERS_API and display their online status.
      function normalizePlayerName(p){ return p.name || p.username || p.nick || p.displayName || (p.id?String(p.id):String(p)); }
      function detectPlayerOnline(p){
        if(typeof p.online === 'boolean') return p.online;
        if(typeof p.active === 'boolean') return p.active;
        if(typeof p.isOnline === 'boolean') return p.isOnline;
        if(typeof p.status === 'string') return p.status.toLowerCase().includes('online');
        if(typeof p.online === 'string') return p.online.toLowerCase() === 'true';
        return false;
      }

      async function fetchPlayers(){
        try{
          const res = await fetch(PLAYERS_API);
          if(!res.ok) throw new Error('Players fetch failed: '+res.status);
          const data = await res.json();
          if(!Array.isArray(data)){ playersStatusEl.textContent='No players data'; playersListEl.innerHTML=''; return; }

          const onlineList = [];
          const offlineList = [];
          for(const p of data){
            const name = normalizePlayerName(p);
            const on = detectPlayerOnline(p);
            if(on) onlineList.push({name, raw:p});
            else offlineList.push({name, raw:p});
          }

          // ensure local user visible
          if(username){
            const existsOnline = onlineList.some(x=>x.name===username);
            const existsOffline = offlineList.some(x=>x.name===username);
            if(!existsOnline && !existsOffline){
              onlineList.unshift({name: username, raw:{name:username, online:true}, local:true});
            }
          }

          playersListEl.innerHTML = '';
          const headerOnline = document.createElement('div'); headerOnline.style.fontSize='13px'; headerOnline.style.color='var(--muted)'; headerOnline.textContent = 'Online ('+onlineList.length+')';
          playersListEl.appendChild(headerOnline);
          for(const p of onlineList){
            const item = document.createElement('div');
            item.className = 'player online' + (p.local ? ' you' : '');
            const displayName = escapeHtml(p.name);
            const youLabel = p.local ? ' <span style="margin-left:6px;font-size:12px;color:var(--muted)">(you)</span>' : '';
            item.innerHTML = `<div style="display:flex;align-items:center"><span class="statusDot"></span><span class="playerName" style="font-weight:600">${displayName}</span>${youLabel}</div><div style="font-size:12px;color:var(--muted)">online</div>`;
            const nameSpan = item.querySelector('.playerName');
            if(p.raw && (p.raw.nameColor || p.raw.color)) nameSpan.style.color = p.raw.nameColor || p.raw.color;
            else if(p.local) nameSpan.style.color = nameColor;
            playersListEl.appendChild(item);
          }

          const sep = document.createElement('div'); sep.style.height='8px'; playersListEl.appendChild(sep);

          const headerOff = document.createElement('div'); headerOff.style.fontSize='13px'; headerOff.style.color='var(--muted)'; headerOff.textContent = 'Offline ('+offlineList.length+')';
          playersListEl.appendChild(headerOff);
          for(const p of offlineList){
            const item = document.createElement('div');
            item.className = 'player offline';
            const displayName = escapeHtml(p.name);
            item.innerHTML = `<div style="display:flex;align-items:center"><span class="statusDot"></span><span class="playerName" style="font-weight:600">${displayName}</span></div><div style="font-size:12px;color:var(--muted)">offline</div>`;
            const nameSpan = item.querySelector('.playerName');
            if(p.raw && (p.raw.nameColor || p.raw.color)) nameSpan.style.color = p.raw.nameColor || p.raw.color;
            playersListEl.appendChild(item);
          }

          playersStatusEl.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
        }catch(err){
          console.error(err);
          playersStatusEl.textContent = 'Error loading players';
          playersListEl.innerHTML = '';
        }
      }

      // Upsert local player into PLAYERS_API (find by name or create), store id in localStorage
      async function upsertLocalPlayer(){
        if(!username) return;
        try{
          const res = await fetch(PLAYERS_API);
          if(!res.ok) throw new Error('Players fetch failed: '+res.status);
          const data = await res.json();
          if(!Array.isArray(data)) return;
          const found = data.find(p => normalizePlayerName(p) === username);
          if(found){
            localPlayerId = found.id;
            localStorage.setItem('notcord_playerId', localPlayerId);
            await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', {...found, name: username, online:true, nameColor});
          } else {
            const created = await safeFetch(PLAYERS_API, 'POST', { name: username, online:true, nameColor });
            if(created && created.id){ localPlayerId = created.id; localStorage.setItem('notcord_playerId', localPlayerId); }
          }
        }catch(e){
          console.warn('upsertLocalPlayer error', e);
        } finally { fetchPlayers().catch(()=>{}); }
      }

      // Mark local player offline/online on API (best-effort)
      async function setLocalPlayerOnlineState(isOnline){
        if(!localPlayerId) return;
        try{
          const cur = await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'GET', null);
          if(!cur) return;
          const updated = { ...cur, online: !!isOnline, name: username || cur.name };
          if(nameColor) updated.nameColor = nameColor;
          await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', updated);
        }catch(e){ console.warn('setLocalPlayerOnlineState', e); } finally { fetchPlayers().catch(()=>{}); }
      }

      // safeFetch helper
      async function safeFetch(url, method='GET', body=null){
        try{
          const opts = { method, headers:{} };
          if(body !== null){ opts.headers['Content-Type']='application/json'; opts.body = JSON.stringify(body); }
          const r = await fetch(url, opts);
          if(!r.ok){ console.warn('safeFetch non-OK', r.status, url); return null; }
          return await r.json();
        }catch(e){ console.warn('safeFetch failed', e, url); return null; }
      }

      // Typing indicator using localStorage map { channel: { user: timestamp } }
      function readTypingMap(){ try{ return JSON.parse(localStorage.getItem(TYPING_KEY)||'{}'); }catch(e){ return {}; } }
      function writeTypingMap(m){ try{ localStorage.setItem(TYPING_KEY, JSON.stringify(m)); }catch(e){} }
      function setLocalTyping(active){
        if(!username) return;
        const map = readTypingMap();
        map[activeChannel] = map[activeChannel] || {};
        if(active) map[activeChannel][username] = Date.now();
        else if(map[activeChannel]) delete map[activeChannel][username];
        writeTypingMap(map);
        updateTypingUI();
      }

      function cleanupTypingMap(){
        const map = readTypingMap();
        const now = Date.now();
        let changed = false;
        for(const ch of Object.keys(map)){
          for(const u of Object.keys(map[ch])){
            const ts = Number(map[ch][u]||0);
            if(now - ts > TYPING_EXPIRE_MS){ delete map[ch][u]; changed = true; }
          }
          if(Object.keys(map[ch]).length === 0) delete map[ch];
        }
        if(changed) writeTypingMap(map);
        updateTypingUI();
      }

      function updateTypingUI(){
        const map = readTypingMap();
        const channelMap = map[activeChannel] || {};
        const now = Date.now();
        const typers = Object.keys(channelMap).filter(u => u !== username && (now - Number(channelMap[u]||0) <= TYPING_EXPIRE_MS));
        if(typers.length === 0) typingIndicatorEl.textContent = '';
        else if(typers.length === 1) typingIndicatorEl.textContent = typers[0] + ' is typing...';
        else if(typers.length === 2) typingIndicatorEl.textContent = typers[0] + ' and ' + typers[1] + ' are typing...';
        else typingIndicatorEl.textContent = typers[0] + ' and ' + (typers.length-1) + ' others are typing...';
      }
      window.addEventListener('storage', (e)=> { if(e.key === TYPING_KEY) updateTypingUI(); });

      // Input & UI helpers
      function updateCharCountAndState(){
        let val = messageInput.value || '';
        if(val.length > MAX_CHARS) messageInput.value = val.slice(0, MAX_CHARS);
        charCountEl.textContent = `${(messageInput.value||'').length} / ${MAX_CHARS}`;
        const canSend = username && (messageInput.value||'').trim().length > 0 && activeChannel !== 'announcements' && !isSending;
        sendBtn.disabled = !canSend;
      }

      function scheduleTypingStop(){
        if(typingStopTimeout) clearTimeout(typingStopTimeout);
        typingStopTimeout = setTimeout(()=> {
          setLocalTyping(false);
          isLocalTyping = false;
        }, 1500);
      }

      // Manage autoScroll when user scrolls up/down
      messagesEl.addEventListener('scroll', () => {
        autoScroll = isAtBottom();
      });

      // Events
      channelsEl.addEventListener('click', (e)=>{
        const ch = e.target.closest('.channel');
        if(!ch) return;
        setActiveChannel(ch.dataset.id).catch(()=>{});
      });

      setNameBtn.addEventListener('click', async ()=>{
        let val = usernameInput.value.trim();
        if(!val) val = 'Guest' + Math.floor(Math.random()*9000 + 1000);
        username = val;
        localStorage.setItem('notcord_username', username);
        usernameBox.style.display = 'none';
        usernameLocked.style.display = 'flex';
        usernameDisplay.textContent = username;
        await upsertLocalPlayer();
        await fetchPlayers();
        updateCharCountAndState();
      });

      sendBtn.addEventListener('click', ()=>{
        const txt = messageInput.value;
        if(!txt || !txt.trim()) return;
        postMessage(txt);
        messageInput.value = '';
        updateCharCountAndState();
        setLocalTyping(false);
      });

      messageInput.addEventListener('input', ()=>{
        if(messageInput.value.length > MAX_CHARS) messageInput.value = messageInput.value.slice(0, MAX_CHARS);
        updateCharCountAndState();
        if(!isLocalTyping){ setLocalTyping(true); isLocalTyping = true; }
        scheduleTypingStop();
      });

      messageInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); if(!sendBtn.disabled) sendBtn.click(); }
      });

      nameColorInput.addEventListener('input', async (e)=>{
        nameColor = e.target.value;
        localStorage.setItem('notcord_nameColor', nameColor);
        if(localPlayerId){
          const cur = await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'GET', null);
          if(cur) await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', {...cur, nameColor});
        }
        Array.from(document.querySelectorAll('.meta .name')).forEach(el => { if(el.textContent === username) el.style.color = nameColor; });
        fetchPlayers().catch(()=>{});
      });
      resetNameColorBtn.addEventListener('click', ()=>{ nameColor = '#ffcc00'; nameColorInput.value = nameColor; localStorage.setItem('notcord_nameColor', nameColor); });

      themeColor1Input.addEventListener('input', (e)=>{ themeColor1 = e.target.value; localStorage.setItem('notcord_theme1', themeColor1); accentColor = themeColor1; localStorage.setItem('notcord_accent', accentColor); applyTheme(); });
      resetTheme1Btn.addEventListener('click', ()=>{ themeColor1 = '#071226'; themeColor1Input.value = themeColor1; localStorage.setItem('notcord_theme1', themeColor1); applyTheme(); });
      themeColor2Input.addEventListener('input', (e)=>{ themeColor2 = e.target.value; localStorage.setItem('notcord_theme2', themeColor2); applyTheme(); });
      resetTheme2Btn.addEventListener('click', ()=>{ themeColor2 = '#07101a'; themeColor2Input.value = themeColor2; localStorage.setItem('notcord_theme2', themeColor2); applyTheme(); });

      // Channel switch logic
      async function setActiveChannel(id){
        activeChannel = id;
        apiBase = CHANNELS[id] || null;
        localStorage.setItem('notcord_channel', id);
        Array.from(channelsEl.children).forEach(ch => ch.classList.toggle('active', ch.dataset.id === id));
        channelTitleEl.textContent = '# ' + id;
        if(id === 'announcements'){ messageInput.disabled = true; messageInput.placeholder = 'Read-only channel'; sendBtn.disabled = true; charCountEl.style.opacity = 0.5; }
        else { messageInput.disabled = false; messageInput.placeholder = 'Message (Shift+Enter for newline)'; charCountEl.style.opacity = 1; updateCharCountAndState(); }
        if(polling) clearInterval(polling);
        await fetchMessages();
        if(id !== 'announcements') polling = setInterval(fetchMessages, 4000);
      }

      // Visibility & focus handling: mark online when focused, offline when hidden or closed
      document.addEventListener('visibilitychange', async () => {
        if(!username) return;
        if(document.hidden){
          // Mark offline when tabbed out
          await setLocalPlayerOnlineState(false).catch(()=>{});
        } else {
          // Mark online when tab focused again (and ensure player record exists)
          await upsertLocalPlayer().catch(()=>{});
          await setLocalPlayerOnlineState(true).catch(()=>{});
        }
      });

      window.addEventListener('blur', async () => {
        if(!username) return;
        await setLocalPlayerOnlineState(false).catch(()=>{});
      });

      window.addEventListener('focus', async () => {
        if(!username) return;
        await upsertLocalPlayer().catch(()=>{});
        await setLocalPlayerOnlineState(true).catch(()=>{});
      });

      // Init
      async function init(){
        applyTheme();
        initializeAppearanceInputs();
        localPlayerId = localStorage.getItem('notcord_playerId') || null;

        if(username){
          usernameBox.style.display = 'none';
          usernameLocked.style.display = 'flex';
          usernameDisplay.textContent = username;
          await upsertLocalPlayer();
          await setLocalPlayerOnlineState(true);
        } else {
          usernameBox.style.display = 'flex';
          usernameLocked.style.display = 'none';
        }

        await setActiveChannel(activeChannel);
        await fetchPlayers();
        if(playersPolling) clearInterval(playersPolling);
        playersPolling = setInterval(fetchPlayers, 5000);

        setStatus('Connected (polling every 4s)');
        setInterval(cleanupTypingMap, 2000);
        updateTypingUI();
        setTimeout(scrollToBottom, 120);
      }
      init();

      // Before unload: mark offline & clear typing
      window.addEventListener('beforeunload', ()=>{
        try{
          if(localPlayerId){
            const payload = JSON.stringify({ name: username, online:false, nameColor });
            const url = `${PLAYERS_API}/${localPlayerId}`;
            if(navigator.sendBeacon){
              navigator.sendBeacon(url, payload);
            } else {
              fetch(url, { method:'PUT', headers:{'Content-Type':'application/json'}, body: payload }).catch(()=>{});
            }
          }
        }catch(e){}
        // clear typing entry
        try{
          const map = readTypingMap();
          if(map[activeChannel] && map[activeChannel][username]) { delete map[activeChannel][username]; writeTypingMap(map); }
        }catch(e){}
      });
    })();
  </script>
</body>
</html>
