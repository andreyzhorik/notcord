<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Discord-like Chat (MockAPI)</title>
  <style>
    :root{
      --bg:#0f1720;
      --panel:#0b1220;
      --muted:#9aa4b2;
      --accent:#5865f2;
      --msg-bg:#111827;
      --me-bg:#2b3440;
      --border: rgba(255,255,255,0.06);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      height:100vh;
      font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:linear-gradient(180deg,#071226 0%, #07101a 100%);
      color:#e6eef6;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:20px;
    }

    .app {
      width:100%;
      max-width:1000px;
      height:80vh;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:12px;
      display:grid;
      grid-template-columns:260px 1fr;
      overflow:hidden;
      border:1px solid var(--border);
      box-shadow: 0 10px 30px rgba(2,6,23,0.7);
    }

    /* Left sidebar */
    .sidebar{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      padding:16px;
      border-right:1px solid var(--border);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .brand{
      display:flex;
      gap:10px;
      align-items:center;
      font-weight:700;
      color:var(--accent);
    }
    .brand .dot{
      width:12px;height:12px;border-radius:50%;
      background:var(--accent);
      box-shadow:0 0 10px rgba(88,101,242,0.6);
    }
    .usernameBox{
      margin-top:8px;
      display:flex;
      gap:8px;
      align-items:center;
    }
    .usernameBox input{
      flex:1;
      padding:8px;
      background:transparent;
      border:1px solid var(--border);
      border-radius:8px;
      color:inherit;
      outline:none;
    }
    .usernameBox button{
      background:transparent;
      border:1px solid var(--border);
      color:var(--muted);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
    }
    .channels{
      margin-top:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
      color:var(--muted);
      font-size:14px;
    }

    /* Chat panel */
    .chatPanel{
      display:flex;
      flex-direction:column;
      background:var(--panel);
      position:relative;
    }
    .header{
      padding:14px 18px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      gap:12px;
    }
    .header h2{
      margin:0;
      font-size:18px;
    }
    .messages{
      flex:1;
      overflow:auto;
      padding:20px;
      display:flex;
      flex-direction:column;
      gap:14px;
      scroll-behavior:smooth;
    }

    .message{
      display:flex;
      gap:12px;
      align-items:flex-start;
      max-width:90%;
    }
    .message.me{flex-direction:row-reverse; margin-left:auto; max-width:85%;}
    .avatar{
      width:44px;height:44px;border-radius:8px;flex:0 0 44px;overflow:hidden;
      background:#0f1720;border:1px solid var(--border);
    }
    .bubble{
      background:var(--msg-bg);
      padding:10px 12px;
      border-radius:10px;
      box-shadow: 0 4px 8px rgba(2,6,23,0.5);
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width:120px;
      word-wrap:break-word;
    }
    .message.me .bubble{background:var(--me-bg);}
    .meta{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }
    .meta .name{color:#e6eef6;font-weight:600}
    .time{font-size:12px;color:var(--muted)}
    .text{white-space:pre-wrap; color:#dbe8ff; font-size:15px}

    .inputArea{
      padding:12px;
      border-top:1px solid var(--border);
      display:flex;
      gap:8px;
      align-items:flex-end;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    }
    .inputArea textarea{
      flex:1;
      min-height:44px;
      max-height:140px;
      resize:none;
      padding:10px;
      border-radius:10px;
      background:transparent;
      border:1px solid var(--border);
      color:inherit;
      outline:none;
      font-family:inherit;
    }
    .sendBtn{
      background:var(--accent);
      border:none;
      color:white;
      padding:10px 14px;
      border-radius:10px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight:600;
    }
    .sendBtn:disabled{opacity:0.6;cursor:default}

    .status{padding:8px 14px;color:var(--muted);font-size:13px}

    /* small screens */
    @media (max-width:720px){
      .app{grid-template-columns:1fr; height:92vh}
      .sidebar{display:none}
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <aside class="sidebar">
      <div class="brand">
        <div class="dot" aria-hidden></div>
        <div>MockChat</div>
      </div>

      <div class="usernameBox">
        <input type="text" id="username" placeholder="Your username" maxlength="40" />
        <button id="saveName">Save</button>
      </div>

      <div class="channels">
        <div># general</div>
        <div># bot-commands</div>
        <div># random</div>
      </div>

      <div class="status" id="status">Connecting...</div>
    </aside>

    <section class="chatPanel" aria-live="polite">
      <div class="header">
        <h2># general</h2>
        <div style="flex:1"></div>
        <div id="lastSync" style="color:var(--muted);font-size:13px"></div>
      </div>

      <div class="messages" id="messages" role="log" aria-atomic="false"></div>

      <div class="inputArea">
        <textarea id="messageInput" placeholder="Message #general (Shift+Enter for newline)"></textarea>
        <button class="sendBtn" id="sendBtn">Send</button>
      </div>
    </section>
  </div>

  <script>
    (function(){
      const API_BASE = 'https://68e839b2f2707e6128ca35e1.mockapi.io/chat';
      // DOM
      const messagesEl = document.getElementById('messages');
      const usernameInput = document.getElementById('username');
      const saveNameBtn = document.getElementById('saveName');
      const statusEl = document.getElementById('status');
      const lastSyncEl = document.getElementById('lastSync');
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');

      // app state
      let username = localStorage.getItem('mockchat_username') || generateGuest();
      usernameInput.value = username;
      let polling = null;
      let lastFetchedIds = new Set();
      let isSending = false;

      // utils
      function generateGuest(){
        return 'Guest' + Math.floor(Math.random()*9000 + 1000);
      }
      function avatarUrl(name){
        // Use dicebear identicon (avatar) for consistent avatars
        return 'https://api.dicebear.com/8.x/initials/svg?seed=' + encodeURIComponent(name) + '&backgroundType=gradient&fontFamily=inter';
      }
      function sanitizeText(str){
        // We'll create text nodes to avoid HTML injection; this helper keeps strings safe when inserted via textContent
        return String(str || '');
      }
      function formatTime(iso){
        try{
          const d = new Date(iso);
          if(isNaN(d)) return '';
          return d.toLocaleString([], { hour: '2-digit', minute: '2-digit' });
        }catch(e){ return '';}
      }
      function findMessageText(msg){
        return msg.message || msg.text || msg.content || msg.body || '';
      }
      function findMessageAuthor(msg){
        return msg.username || msg.name || msg.author || 'Unknown';
      }
      function findAvatarField(msg, author){
        return msg.avatar || msg.avatarUrl || avatarUrl(author);
      }

      // Rendering
      function renderMessage(msg, isMe=false){
        const container = document.createElement('div');
        container.className = 'message' + (isMe ? ' me' : '');

        const avatar = document.createElement('div');
        avatar.className = 'avatar';

        const img = document.createElement('img');
        img.src = findAvatarField(msg, findMessageAuthor(msg));
        img.alt = '';
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        img.onerror = function(){ avatar.style.background = '#18202b'; img.style.display='none' };

        avatar.appendChild(img);

        const bubble = document.createElement('div');
        bubble.className = 'bubble';

        const meta = document.createElement('div');
        meta.className = 'meta';
        const name = document.createElement('span');
        name.className = 'name';
        name.textContent = findMessageAuthor(msg);

        const time = document.createElement('span');
        time.className = 'time';
        // use createdAt or id fallback
        time.textContent = formatTime(msg.createdAt || msg.created_at || msg.createdAt || msg.timestamp || msg.time || '');

        meta.appendChild(name);
        meta.appendChild(time);

        const text = document.createElement('div');
        text.className = 'text';
        text.textContent = findMessageText(msg);

        bubble.appendChild(meta);
        bubble.appendChild(text);

        // append in order dependent on me or not
        if(isMe){
          container.appendChild(avatar);
          container.appendChild(bubble);
        } else {
          container.appendChild(avatar);
          container.appendChild(bubble);
        }
        return container;
      }

      function setStatus(txt){
        statusEl.textContent = txt;
      }

      // Fetch messages
      async function fetchMessages(){
        try{
          const res = await fetch(API_BASE);
          if(!res.ok) throw new Error('Fetch failed: ' + res.status);
          const data = await res.json();
          if(!Array.isArray(data)) return;

          // sort by createdAt or id
          data.sort((a,b) => {
            const ta = new Date(a.createdAt || a.created_at || a.timestamp || 0).getTime() || (Number(a.id) || 0);
            const tb = new Date(b.createdAt || b.created_at || b.timestamp || 0).getTime() || (Number(b.id) || 0);
            return ta - tb;
          });

          // render all messages (simple approach) but avoid duplicates by tracking ids
          messagesEl.innerHTML = '';
          lastFetchedIds.clear();
          for(const msg of data){
            const id = msg.id ?? JSON.stringify(msg);
            lastFetchedIds.add(String(id));
            const isMe = (findMessageAuthor(msg) === username);
            const msgEl = renderMessage(msg, isMe);
            messagesEl.appendChild(msgEl);
          }
          scrollToBottom();
          setStatus('Connected — ' + data.length + ' messages');
          lastSyncEl.textContent = 'Last: ' + new Date().toLocaleTimeString();
        }catch(err){
          console.error(err);
          setStatus('Error fetching messages');
        }
      }

      // Post message
      async function postMessage(text){
        if(!text || text.trim().length === 0) return;
        if(isSending) return;
        isSending = true;
        sendBtn.disabled = true;
        const payload = {
          username: username,
          message: text,
          avatar: avatarUrl(username),
          createdAt: new Date().toISOString()
        };

        // optimistic UI: append immediately
        const optimisticEl = renderMessage(payload, true);
        messagesEl.appendChild(optimisticEl);
        scrollToBottom();

        try{
          const res = await fetch(API_BASE, {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify(payload)
          });
          if(!res.ok) throw new Error('Send failed: ' + res.status);
          // optionally reconcile by refetching
          await fetchMessages();
        }catch(err){
          console.error(err);
          setStatus('Failed to send message');
          // leave optimistic message but mark as failed (simple visual)
          optimisticEl.querySelector('.meta .time').textContent += ' (failed)';
        }finally{
          isSending = false;
          sendBtn.disabled = false;
        }
      }

      // UI helpers
      function scrollToBottom(){
        requestAnimationFrame(()=> messagesEl.scrollTop = messagesEl.scrollHeight);
      }

      // Event listeners
      saveNameBtn.addEventListener('click', ()=>{
        const val = usernameInput.value.trim() || generateGuest();
        username = val;
        localStorage.setItem('mockchat_username', username);
        setStatus('Username saved: ' + username);
      });

      sendBtn.addEventListener('click', ()=> {
        const text = messageInput.value;
        if(!text.trim()) return;
        postMessage(text.trim());
        messageInput.value = '';
      });

      messageInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' && !e.shiftKey){
          e.preventDefault();
          sendBtn.click();
        }
      });

      // initial load and polling
      fetchMessages();
      setStatus('Connected (polling every 4s)');
      polling = setInterval(fetchMessages, 4000);

      // graceful unload
      window.addEventListener('beforeunload', ()=> {
        if(polling) clearInterval(polling);
      });

      // accessibility: focus message input
      messageInput.focus();

    })();
  </script>
</body>
</html>
