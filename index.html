<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>notcord â€” multi-channel</title>
  <style>
    :root{
      --theme-1: #071226;
      --theme-2: #07101a;
      --panel-overlay: rgba(11,18,32,0.85);
      --muted: #9aa4b2;
      --accent: #5865f2;
      --msg-bg: #111827;
      --me-bg: #2b3440;
      --border: rgba(255,255,255,0.06);
      --text: #e6eef6;
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;color:var(--text);
      background:linear-gradient(180deg,var(--theme-1) 0%, var(--theme-2) 100%);
    }

    .app {
      width:100%;
      height:100vh;
      display:grid;
      grid-template-columns:260px 1fr 220px;
      gap:0;
      overflow:hidden;
      align-items:stretch;
    }

    /* Left sidebar */
    .sidebar{
      background: linear-gradient(180deg, rgba(0,0,0,0.08), rgba(0,0,0,0.02)), linear-gradient(180deg,var(--theme-1),var(--theme-2));
      border-right:1px solid var(--border);
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
      height:100vh;
      overflow:auto;
      flex-shrink:0;
    }

    .brand{display:flex;gap:10px;align-items:center;font-weight:700;color:var(--accent);font-size:18px;white-space:nowrap}
    /* dot uses the two theme colors */
    .brand .dot{
      width:12px;height:12px;border-radius:50%;
      background:linear-gradient(135deg,var(--theme-1),var(--theme-2));
      box-shadow:0 0 8px rgba(0,0,0,0.6), 0 0 18px rgba(86,101,242,0.15);
      flex-shrink:0;
    }
    /* text draws gradient from theme colors */
    .brand .name{
      background:linear-gradient(90deg,var(--theme-1),var(--theme-2));
      -webkit-background-clip:text;background-clip:text;color:transparent;
      font-weight:800;
      font-size:18px;
      letter-spacing:0.2px;
    }

    .usernameBox{display:flex;gap:8px;align-items:center}
    .usernameBox input{flex:1;padding:8px;background:transparent;border:1px solid var(--border);border-radius:8px;color:inherit;outline:none;min-width:0}
    .usernameBox button{padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--muted);cursor:pointer}
    .usernameLocked{display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid var(--border);font-weight:600;overflow:hidden}
    .usernameLocked #usernameDisplay{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;max-width:100%}

    .channels{margin-top:6px;display:flex;flex-direction:column;gap:6px}
    .channel{padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer;border:1px solid transparent;display:flex;justify-content:space-between;align-items:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .channel:hover{background:rgba(255,255,255,0.01)}
    .channel.active{background:linear-gradient(90deg, rgba(88,101,242,0.12), rgba(88,101,242,0.02));color:var(--text);border-color:rgba(88,101,242,0.12)}
    .channel .lock{font-size:12px;color:var(--muted);margin-left:8px}

    .settings{margin-top:auto;display:flex;flex-direction:column;gap:8px;padding-top:8px;border-top:1px solid var(--border)}
    .settings label{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px}
    .settings input[type="color"]{width:48px;height:32px;padding:0;border:none;background:transparent;cursor:pointer}
    .settings .toggleBtn{padding:8px;border-radius:8px;background:transparent;border:1px solid var(--border);color:var(--muted);cursor:pointer}

    /* Main chat */
    .chatPanel{display:flex;flex-direction:column;background:transparent;position:relative;min-height:0}
    .header{padding:12px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px}
    .header h2{margin:0;font-size:18px}
    .header .spacer{flex:1}
    .messages{flex:1;overflow:auto;padding:20px;display:flex;flex-direction:column;gap:12px;scroll-behavior:smooth;min-height:0}
    .message{display:flex;gap:12px;align-items:flex-start;max-width:85%}
    .message.me{margin-left:auto;justify-content:flex-end}
    .bubble{background:var(--msg-bg);padding:10px 12px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);display:flex;flex-direction:column;gap:6px;color:#dbe8ff;word-break:break-word}
    .message.me .bubble{background:var(--me-bg)}
    .meta{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
    .meta .name{font-weight:700}
    .meta .time{font-size:12px;color:var(--muted)}
    .text{white-space:pre-wrap;color:inherit;font-size:15px;word-break:break-word;overflow-wrap:break-word}

    .inputArea{padding:12px;border-top:1px solid var(--border);display:flex;gap:8px;align-items:flex-end;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
    .inputArea textarea{flex:1;min-height:44px;max-height:160px;resize:none;padding:10px;border-radius:10px;background:transparent;border:1px solid var(--border);color:inherit;outline:none;min-width:0}
    .controls{display:flex;flex-direction:column;align-items:flex-end;gap:6px;min-width:120px}
    .charCount{font-size:12px;color:var(--muted)}
    .sendBtn{background:var(--accent);border:none;color:white;padding:10px 14px;border-radius:10px;cursor:pointer;display:inline-flex;align-items:center;gap:8px;font-weight:600}
    .sendBtn:disabled{opacity:0.6;cursor:default}

    /* Right players panel */
    .playersPanel{
      background: linear-gradient(180deg, rgba(0,0,0,0.06), rgba(0,0,0,0.02)), linear-gradient(180deg,var(--theme-1),var(--theme-2));
      border-left:1px solid var(--border);
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
      height:100vh;
      overflow:auto;
      flex-shrink:0;
    }
    .playersPanel h3{margin:0;font-size:15px;color:var(--muted)}
    .playersList{display:flex;flex-direction:column;gap:6px;overflow:auto}
    .player{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid transparent;color:var(--text)}
    .player.offline{opacity:0.6}
    .player .statusDot{width:10px;height:10px;border-radius:50%;margin-right:8px;flex-shrink:0}
    .player.online .statusDot{background:#39d353;box-shadow:0 0 8px rgba(57,211,83,0.12)}
    .player.offline .statusDot{background:#a0a0a0}

    @media (max-width:980px){
      .app{grid-template-columns:220px 1fr 180px}
    }
    @media (max-width:720px){
      .app{grid-template-columns:1fr}
      .sidebar,.playersPanel{display:none}
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <aside class="sidebar" id="sidebar">
      <div class="brand">
        <div class="dot" aria-hidden></div>
        <div class="name">notcord</div>
      </div>

      <div id="usernameSection">
        <div class="usernameBox" id="usernameBox">
          <input type="text" id="usernameInput" placeholder="Choose username (once)" maxlength="40" />
          <button id="setNameBtn">Set</button>
        </div>
        <div class="usernameLocked" id="usernameLocked" style="display:none">
          <div id="usernameDisplay"></div>
        </div>
      </div>

      <div class="channels" id="channels">
        <div class="channel active" data-id="general" role="button"># general</div>
        <div class="channel" data-id="school" role="button"># school</div>
        <div class="channel" data-id="games" role="button"># games</div>
        <!-- read-only channel; edit READ_ONLY_MESSAGES in the JS below to change its contents -->
        <div class="channel" data-id="announcements" role="button"># announcements <span class="lock">ðŸ”’</span></div>
      </div>

      <div class="settings" aria-label="Appearance settings">
        <label>
          Your name color
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="nameColor" title="Name color" />
            <div style="flex:1"></div>
            <button id="resetNameColor" class="toggleBtn">Reset</button>
          </div>
        </label>

        <label>
          Theme color 1
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="themeColor1" title="Theme color 1" />
            <div style="flex:1"></div>
            <button id="resetTheme1" class="toggleBtn">Reset</button>
          </div>
        </label>

        <label>
          Theme color 2
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="themeColor2" title="Theme color 2" />
            <div style="flex:1"></div>
            <button id="resetTheme2" class="toggleBtn">Reset</button>
          </div>
        </label>

        <div style="font-size:12px;color:var(--muted);padding-top:6px">Username and appearance are saved in this browser.</div>
      </div>
    </aside>

    <section class="chatPanel">
      <div class="header">
        <h2 id="channelTitle"># general</h2>
        <div class="spacer"></div>
        <div id="status" style="color:var(--muted);font-size:13px">Connecting...</div>
      </div>

      <div class="messages" id="messages" role="log" aria-atomic="false"></div>

      <div class="inputArea" id="inputArea">
        <textarea id="messageInput" placeholder="Message (Shift+Enter for newline)" maxlength="100"></textarea>
        <div class="controls">
          <div class="charCount" id="charCount">0 / 100</div>
          <button id="sendBtn" class="sendBtn" disabled>Send</button>
        </div>
      </div>
    </section>

    <aside class="playersPanel" id="playersPanel">
      <h3>Players</h3>
      <div id="playersStatus" style="font-size:13px;color:var(--muted)">Loading...</div>
      <div style="height:6px"></div>
      <div class="playersList" id="playersList" aria-live="polite"></div>
    </aside>
  </div>

  <script>
    (function(){
      // Channel endpoints (APIs)
      const CHANNELS = {
        general: 'https://68e839b2f2707e6128ca35e1.mockapi.io/chat',
        school:  'https://68eeed86b06cc802829ba196.mockapi.io/schoolchat',
        games:   'https://68eeed86b06cc802829ba196.mockapi.io/gameschat'
        // announcements intentionally omitted to make it read-only and editable via code
      };
      const PLAYERS_API = 'https://68e839b2f2707e6128ca35e1.mockapi.io/players';

      // READ-ONLY channel content:
      // Edit this array in the code to change what shows in #announcements.
      // Each item should be an object: { username: 'Author', message: 'Text', createdAt: 'ISO string', nameColor: '#hex' (optional) }
      const READ_ONLY_MESSAGES = [
        { username: 'Admin', message: 'Welcome to notcord â€” check pinned notes here.', createdAt: new Date().toISOString(), nameColor: '#ff7a18' },
        { username: 'Team',  message: 'Server maintenance scheduled: Sunday 02:00 UTC.', createdAt: new Date(Date.now() - 1000 * 60 * 60 * 6).toISOString(), nameColor: '#18a0ff' }
      ];

      // DOM references
      const rootEl = document.documentElement;
      const channelsEl = document.getElementById('channels');
      const channelTitleEl = document.getElementById('channelTitle');
      const messagesEl = document.getElementById('messages');
      const statusEl = document.getElementById('status');
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');
      const charCountEl = document.getElementById('charCount');
      const inputArea = document.getElementById('inputArea');

      const usernameBox = document.getElementById('usernameBox');
      const usernameInput = document.getElementById('usernameInput');
      const setNameBtn = document.getElementById('setNameBtn');
      const usernameLocked = document.getElementById('usernameLocked');
      const usernameDisplay = document.getElementById('usernameDisplay');

      const nameColorInput = document.getElementById('nameColor');
      const themeColor1Input = document.getElementById('themeColor1');
      const themeColor2Input = document.getElementById('themeColor2');
      const resetNameColorBtn = document.getElementById('resetNameColor');
      const resetTheme1Btn = document.getElementById('resetTheme1');
      const resetTheme2Btn = document.getElementById('resetTheme2');

      const playersListEl = document.getElementById('playersList');
      const playersStatusEl = document.getElementById('playersStatus');

      // state
      let activeChannel = localStorage.getItem('notcord_channel') || 'general';
      let apiBase = CHANNELS[activeChannel] || null;
      let polling = null;
      let playersPolling = null;
      let isSending = false;
      const MAX_CHARS = 100;

      // user settings
      let username = localStorage.getItem('notcord_username') || '';
      let nameColor = localStorage.getItem('notcord_nameColor') || '#ffcc00';
      let themeColor1 = localStorage.getItem('notcord_theme1') || '#071226';
      let themeColor2 = localStorage.getItem('notcord_theme2') || '#07101a';
      let accentColor = localStorage.getItem('notcord_accent') || themeColor1;

      // theme application
      function applyTheme(){
        document.documentElement.style.setProperty('--theme-1', themeColor1);
        document.documentElement.style.setProperty('--theme-2', themeColor2);
        document.documentElement.style.setProperty('--accent', accentColor || themeColor1);
        // Update dot gradient immediately (CSS variables handle it)
      }

      function initializeAppearanceInputs(){
        nameColorInput.value = nameColor;
        themeColor1Input.value = themeColor1;
        themeColor2Input.value = themeColor2;
      }

      function setStatus(txt){
        statusEl.textContent = txt;
      }

      // message rendering (respects message-provided color)
      function detectNameColorFromMsg(msg){
        return msg.nameColor || msg.color || msg.name_color || msg.colorHex || msg.colour || null;
      }

      function renderMessage(msg, isMe=false){
        const container = document.createElement('div');
        container.className = 'message' + (isMe ? ' me' : '');

        const bubble = document.createElement('div');
        bubble.className = 'bubble';

        const meta = document.createElement('div');
        meta.className = 'meta';
        const name = document.createElement('span');
        name.className = 'name';
        const author = msg.username || msg.name || msg.author || 'Unknown';
        name.textContent = author;

        const msgColor = detectNameColorFromMsg(msg);
        if(msgColor){
          name.style.color = msgColor;
        } else if(author === username && nameColor){
          name.style.color = nameColor;
        }

        const time = document.createElement('span');
        time.className = 'time';
        const created = msg.createdAt || msg.created_at || msg.timestamp || msg.time || '';
        time.textContent = formatTime(created);

        meta.appendChild(name);
        meta.appendChild(time);

        const text = document.createElement('div');
        text.className = 'text';
        text.textContent = msg.message || msg.text || msg.content || msg.body || '';

        bubble.appendChild(meta);
        bubble.appendChild(text);
        container.appendChild(bubble);
        return container;
      }

      function formatTime(iso){
        try{
          const d = new Date(iso);
          if(isNaN(d)) return '';
          return d.toLocaleString([], { hour: '2-digit', minute: '2-digit' });
        }catch(e){ return ''; }
      }

      function scrollToBottom(){
        requestAnimationFrame(()=> { messagesEl.scrollTop = messagesEl.scrollHeight; });
      }

      // fetch messages from API (for writable channels)
      async function fetchMessagesFromApi(){
        if(!apiBase) return false;
        try{
          const res = await fetch(apiBase);
          if(!res.ok) throw new Error('Fetch failed: ' + res.status);
          const data = await res.json();
          if(!Array.isArray(data)) return false;

          data.sort((a,b)=>{
            const ta = new Date(a.createdAt||a.created_at||a.timestamp||0).getTime() || (Number(a.id)||0);
            const tb = new Date(b.createdAt||b.created_at||b.timestamp||0).getTime() || (Number(b.id)||0);
            return ta - tb;
          });

          messagesEl.innerHTML = '';
          for(const msg of data){
            const author = msg.username || msg.name || msg.author || '';
            const isMe = (author === username);
            const el = renderMessage(msg, isMe);
            messagesEl.appendChild(el);
          }
          scrollToBottom();
          setStatus('Connected â€” ' + data.length + ' messages');
          return true;
        }catch(err){
          console.error(err);
          setStatus('Error fetching messages');
          return false;
        }
      }

      // load read-only messages from the local array
      async function loadReadOnlyMessages(){
        // read-only messages come from READ_ONLY_MESSAGES; they are editable in this file
        // clone and sort by createdAt
        const data = Array.isArray(READ_ONLY_MESSAGES) ? READ_ONLY_MESSAGES.slice() : [];
        data.sort((a,b) => {
          const ta = new Date(a.createdAt || 0).getTime() || 0;
          const tb = new Date(b.createdAt || 0).getTime() || 0;
          return ta - tb;
        });
        messagesEl.innerHTML = '';
        for(const msg of data){
          const author = msg.username || msg.name || msg.author || '';
          const isMe = (author === username);
          const el = renderMessage(msg, isMe);
          messagesEl.appendChild(el);
        }
        scrollToBottom();
        setStatus('Announcements â€” ' + data.length + ' items (read-only)');
        return true;
      }

      // unified fetch wrapper depending on active channel
      async function fetchMessages(){
        if(activeChannel === 'announcements') return loadReadOnlyMessages();
        return fetchMessagesFromApi();
      }

      // post message (includes nameColor so others see it)
      async function postMessage(text){
        if(!text || !text.trim()) return;
        if(!username){ setStatus('Set username first'); return; }
        if(!apiBase){ setStatus('No channel selected'); return; }
        if(isSending) return;
        isSending = true;
        sendBtn.disabled = true;

        const payload = {
          username: username,
          message: text.trim(),
          createdAt: new Date().toISOString(),
          nameColor: nameColor
        };

        // optimistic UI
        const optimisticEl = renderMessage(payload, true);
        messagesEl.appendChild(optimisticEl);
        scrollToBottom();

        try{
          const res = await fetch(apiBase, {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify(payload)
          });
          if(!res.ok) throw new Error('Send failed: ' + res.status);
          await fetchMessages();
        }catch(err){
          console.error(err);
          setStatus('Failed to send message');
          const timeEl = optimisticEl.querySelector('.meta .time');
          if(timeEl) timeEl.textContent += ' (failed)';
        }finally{
          isSending = false;
          sendBtn.disabled = false;
        }
      }

      // set active channel
      async function setActiveChannel(id){
        activeChannel = id;
        apiBase = CHANNELS[id] || null;
        localStorage.setItem('notcord_channel', id);
        Array.from(channelsEl.children).forEach(ch => ch.classList.toggle('active', ch.dataset.id === id));
        channelTitleEl.textContent = '# ' + id;

        // toggle input availability for read-only channel
        if(id === 'announcements'){
          messageInput.disabled = true;
          messageInput.placeholder = 'Read-only channel';
          sendBtn.disabled = true;
          charCountEl.style.opacity = 0.5;
        } else {
          messageInput.disabled = false;
          messageInput.placeholder = 'Message (Shift+Enter for newline)';
          updateCharCountAndState();
          charCountEl.style.opacity = 1;
        }

        if(polling) clearInterval(polling);
        await fetchMessages();
        scrollToBottom();
        // poll only for writable channels (announcements is static)
        if(id !== 'announcements') polling = setInterval(fetchMessages, 4000);
      }

      // username logic: set once
      function lockUsernameUI(){
        usernameBox.style.display = 'none';
        usernameLocked.style.display = 'flex';
        usernameDisplay.textContent = username;
        // reflect in players panel
        fetchPlayers().catch(()=>{});
      }

      // appearance functions
      function applyNameColor(c){
        nameColor = c;
        localStorage.setItem('notcord_nameColor', nameColor);
        Array.from(document.querySelectorAll('.meta .name')).forEach(el=>{
          if(el.textContent === username) el.style.color = nameColor;
        });
        // color local player's name in players panel
        const you = playersListEl.querySelector('.player.you .playerName');
        if(you) you.style.color = nameColor;
      }

      function applyThemeColor1(c){
        themeColor1 = c;
        localStorage.setItem('notcord_theme1', themeColor1);
        accentColor = themeColor1;
        localStorage.setItem('notcord_accent', accentColor);
        applyTheme();
      }
      function applyThemeColor2(c){
        themeColor2 = c;
        localStorage.setItem('notcord_theme2', themeColor2);
        applyTheme();
      }

      // players handling (reads PLAYERS_API and injects local user)
      function normalizePlayerName(p){
        return p.name || p.username || p.nick || p.displayName || p.id || String(p);
      }
      function detectPlayerOnline(p){
        if(typeof p.online === 'boolean') return p.online;
        if(typeof p.active === 'boolean') return p.active;
        if(typeof p.isOnline === 'boolean') return p.isOnline;
        if(typeof p.status === 'string') return p.status.toLowerCase().includes('online');
        if(typeof p.online === 'string') return p.online.toLowerCase() === 'true';
        return false;
      }

      async function fetchPlayers(){
        try{
          const res = await fetch(PLAYERS_API);
          if(!res.ok) throw new Error('Players fetch failed: ' + res.status);
          const data = await res.json();
          if(!Array.isArray(data)){
            playersStatusEl.textContent = 'No players data';
            playersListEl.innerHTML = '';
            injectLocalPlayerIntoPlayers();
            return;
          }

          const online = [];
          const offline = [];
          for(const p of data){
            const name = normalizePlayerName(p);
            const on = detectPlayerOnline(p);
            if(on) online.push({name, raw:p});
            else offline.push({name, raw:p});
          }

          // ensure local user appears online if they set a name
          if(username){
            const existsOnline = online.some(p=>p.name === username);
            const existsOffline = offline.some(p=>p.name === username);
            if(!existsOnline){
              // remove from offline if present
              for(let i=offline.length-1;i>=0;i--) if(offline[i].name===username) offline.splice(i,1);
              online.unshift({name:username, raw:{}, local:true});
            }
          }

          playersListEl.innerHTML = '';
          const headerOnline = document.createElement('div');
          headerOnline.style.fontSize = '13px';
          headerOnline.style.color = 'var(--muted)';
          headerOnline.textContent = 'Online (' + online.length + ')';
          playersListEl.appendChild(headerOnline);

          for(const p of online){
            const item = document.createElement('div');
            item.className = 'player online' + (p.local ? ' you' : '');
            const displayName = escapeHtml(p.name);
            const youLabel = p.local ? ' <span style="margin-left:6px;font-size:12px;color:var(--muted)">(you)</span>' : '';
            item.innerHTML = `<div style="display:flex;align-items:center"><span class="statusDot" aria-hidden></span><span class="playerName" style="font-weight:600">${displayName}</span>${youLabel}</div><div style="font-size:12px;color:var(--muted)">online</div>`;
            const nameSpan = item.querySelector('.playerName');
            if(p.raw && (p.raw.nameColor || p.raw.color)) {
              nameSpan.style.color = p.raw.nameColor || p.raw.color;
            } else if(p.local) {
              nameSpan.style.color = nameColor;
            }
            playersListEl.appendChild(item);
          }

          const sep = document.createElement('div');
          sep.style.height = '8px';
          playersListEl.appendChild(sep);

          const headerOff = document.createElement('div');
          headerOff.style.fontSize = '13px';
          headerOff.style.color = 'var(--muted)';
          headerOff.textContent = 'Offline (' + offline.length + ')';
          playersListEl.appendChild(headerOff);

          for(const p of offline){
            const item = document.createElement('div');
            item.className = 'player offline';
            const displayName = escapeHtml(p.name);
            item.innerHTML = `<div style="display:flex;align-items:center"><span class="statusDot" aria-hidden></span><span class="playerName" style="font-weight:600">${displayName}</span></div><div style="font-size:12px;color:var(--muted)">offline</div>`;
            playersListEl.appendChild(item);
          }

          playersStatusEl.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
        }catch(err){
          console.error(err);
          playersStatusEl.textContent = 'Error loading players';
          playersListEl.innerHTML = '';
          injectLocalPlayerIntoPlayers();
        }
      }

      // ensure local user shows in players panel if set
      function injectLocalPlayerIntoPlayers(){
        if(!username) return;
        // if already present, color name properly and return
        const youNameEl = playersListEl.querySelector('.player.you .playerName');
        if(youNameEl){
          youNameEl.style.color = nameColor;
          return;
        }
        // otherwise, prepend a local-you entry under online header if present
        const onlineHeader = Array.from(playersListEl.children).find(el => el.textContent && el.textContent.toLowerCase().startsWith('online'));
        const item = document.createElement('div');
        item.className = 'player online you';
        item.innerHTML = `<div style="display:flex;align-items:center"><span class="statusDot" aria-hidden></span><span class="playerName" style="font-weight:600">${escapeHtml(username)}</span> <span style="margin-left:6px;font-size:12px;color:var(--muted)">(you)</span></div><div style="font-size:12px;color:var(--muted)">online</div>`;
        const nameSpan = item.querySelector('.playerName');
        if(nameSpan) nameSpan.style.color = nameColor;
        if(onlineHeader && onlineHeader.nextSibling) playersListEl.insertBefore(item, onlineHeader.nextSibling);
        else playersListEl.insertBefore(item, playersListEl.firstChild);
      }

      function escapeHtml(s){
        return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
      }

      // input helpers
      function updateCharCountAndState(){
        let val = messageInput.value || '';
        if(val.length > MAX_CHARS){
          messageInput.value = val.slice(0, MAX_CHARS);
          val = messageInput.value;
        }
        charCountEl.textContent = `${val.length} / ${MAX_CHARS}`;
        const canSend = username && val.trim().length > 0 && activeChannel !== 'announcements';
        sendBtn.disabled = !canSend || isSending;
      }

      // event bindings
      channelsEl.addEventListener('click', (e)=>{
        const ch = e.target.closest('.channel');
        if(!ch) return;
        setActiveChannel(ch.dataset.id).catch(()=>{});
      });

      setNameBtn.addEventListener('click', ()=>{
        let val = usernameInput.value.trim();
        if(!val) val = 'Guest' + Math.floor(Math.random()*9000 + 1000);
        username = val;
        localStorage.setItem('notcord_username', username);
        lockUsernameUI();
        setStatus('Username set: ' + username);
        fetchPlayers().catch(()=>{});
        updateCharCountAndState();
      });

      sendBtn.addEventListener('click', ()=>{
        const txt = messageInput.value;
        if(!txt.trim()) return;
        postMessage(txt);
        messageInput.value = '';
        updateCharCountAndState();
      });

      messageInput.addEventListener('input', (e)=>{
        if(messageInput.value.length > MAX_CHARS){
          messageInput.value = messageInput.value.slice(0, MAX_CHARS);
        }
        updateCharCountAndState();
      });

      messageInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' && !e.shiftKey){
          e.preventDefault();
          if(!sendBtn.disabled) sendBtn.click();
        }
      });

      nameColorInput.addEventListener('input', (e)=> {
        applyNameColor(e.target.value);
        fetchPlayers().catch(()=>{});
      });
      resetNameColorBtn.addEventListener('click', ()=>{
        applyNameColor('#ffcc00');
        nameColorInput.value = '#ffcc00';
      });

      themeColor1Input.addEventListener('input', (e)=> {
        applyThemeColor1(e.target.value);
      });
      resetTheme1Btn.addEventListener('click', ()=>{
        applyThemeColor1('#071226');
        themeColor1Input.value = '#071226';
      });

      themeColor2Input.addEventListener('input', (e)=> {
        applyThemeColor2(e.target.value);
      });
      resetTheme2Btn.addEventListener('click', ()=>{
        applyThemeColor2('#07101a');
        themeColor2Input.value = '#07101a';
      });

      // initialization
      async function init(){
        // load saved settings
        nameColor = localStorage.getItem('notcord_nameColor') || nameColor;
        themeColor1 = localStorage.getItem('notcord_theme1') || themeColor1;
        themeColor2 = localStorage.getItem('notcord_theme2') || themeColor2;
        accentColor = localStorage.getItem('notcord_accent') || themeColor1;
        applyTheme();
        initializeAppearanceInputs();

        if(username){
          lockUsernameUI();
        } else {
          usernameBox.style.display = 'flex';
          usernameLocked.style.display = 'none';
        }

        // load selected channel, ensure bottom
        await setActiveChannel(activeChannel);

        // players
        await fetchPlayers();
        if(playersPolling) clearInterval(playersPolling);
        playersPolling = setInterval(fetchPlayers, 5000);

        setStatus('Connected (polling every 4s)');
        // ensure scroll to bottom on load
        setTimeout(scrollToBottom, 120);
      }

      init();

      // cleanup
      window.addEventListener('beforeunload', ()=> {
        if(polling) clearInterval(polling);
        if(playersPolling) clearInterval(playersPolling);
      });
    })();
  </script>
</body>
</html>
